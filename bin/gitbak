#!/usr/bin/env ruby

require 'gitbak'
require 'optparse'

# --

usage = 'gitbak [<option(s)>]'

info = <<-END.gsub(/^ {2}/, '')                                 # {{{1
  gitbak - bitbucket/github/gist backup

  === Example Configuration ===

    $ cat >> ~/.gitbak
    dir = '/path/to/mirrors/dir'

    %w{ user1 user2 }.each do |u|
      GitBak::Cfg.auth      :bitbucket, u
      GitBak::Cfg.auth      :github   , u

      GitBak::Cfg.bitbucket "\#{dir}/\#{u}/bitbucket", u, auth: true
      GitBak::Cfg.github    "\#{dir}/\#{u}/github"   , u, auth: true
      GitBak::Cfg.gist      "\#{dir}/\#{u}/gist"     , u, auth: true
    end
    ^D


  === Configuration Methods ===

    GitBak::Cfg.auth        service, user[, password]
    GitBak::Cfg.<service>   dir, user[, options]

    * password is optional; gitbak prompts for unspecified passwords.
    * The services are: bitbucket, github, gist.
    * Service options:
        :auth is optional; can be true (same user) or 'username'.
        :method is optional; defaults to :ssh.
    * Each GitBak::Cfg.<service> call specifies a new configuration.
END
                                                                # }}}1

options = { cfgfile: "#{Dir.home}/.gitbak", verbose: false }

# --

OptionParser.new do |opts|                                      # {{{1
  opts.banner = usage

  opts.on('-c', '--config-file FILE', 'Configuration file') do |f|
    options[:cfgfile] = f
  end

  opts.on('-v', '--[no-]verbose', 'Run verbosely') do |v|
    options[:verbose] = v
  end

  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts, '', info
    exit
  end

  opts.on_tail('--version', 'Show version') do
    puts "gitbak v#{GitBak::VERSION}"
    exit
  end
end.parse!                                                      # }}}1

GitBak.die "usage: #{usage}" unless ARGV.length == 0

# --

module GitBak                                                   # {{{1
  module Cfg
    CFG__ = { bitbucket: [], github: [], gist: [], auth: {} }

    def self.auth (service, user, pass = nil)
      (CFG__[:auth][service] ||= {})[user] = \
        { user: user, pass: pass }
    end

    def self._service (name)
      meta = class << self; self; end
      meta.send(:define_method, name) do |dir, user, opts = {}|
        CFG__[name] << opts.merge(dir: dir, user: user)
      end
    end

    SERVICES.each do |name|
      _service name.downcase.to_sym
    end
  end
end                                                             # }}}1

# --

GitBak.die "Configuration file (#{options[:cfgfile]}) not found." \
  unless GitBak.exists? options[:cfgfile]

load options[:cfgfile]

# --

GitBak::SERVICES.each do |name|                                 # {{{1
  key = name.downcase.to_sym
  GitBak::Cfg::CFG__[:auth].fetch(key, []).each do |k, v|
    p = "#{name} password for #{v[:user]}: "
    v[:pass] ||= GitBak.prompt p, true
  end
end                                                             # }}}1

GitBak::Cfg::CFG__[:auth][:gist] ||= GitBak::Cfg::CFG__[:auth][:github]

# --

GitBak.main GitBak::Cfg::CFG__.merge(options)

# vim: set tw=70 sw=2 sts=2 et fdm=marker :
